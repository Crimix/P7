\chapter{System Overview}\label{ch:sysview}
The developed solution
consists of multiple different parts, including a Queue Server, a webpage front
end, a database, and a set of classification models. As such, this chapter
will be used to give an overview of these different parts, and how they
interact with each other.

\section{Overview}
The developed system consists of four individual parts, the front end web
service, the database, the classification system, and a task queue which handles
users requests. These elements are developed using three different tools or
frameworks: Laravel, C\# and MySQL. The overall architecture of the
system can be seen in \autoref{P7_SystemOverview} where the arrows imply that
different parts are communicating directly with each other.
 
\figx[0.62]{P7_SystemOverview}{System architecture of the BubbleBuster system}

\subsection{GUI} %API, Interfaces, Data Transfer, System Logic The
The part of the system developed in Laravel makes up the front end of the
system, and is used as the user's entry-point to the system. From here, the
user can make requests to analyze a filter bubble using a Twitter username, and
view the data derived from the analysis. As the solution is centered around a web
application, it is scalable as it can support input from multiple users
at a time, it is also possible to acquire more servers if needed. 

\subsection{Database and API}
The database API is developed using the Laravel framework described in
\autoref{sec:laravel}, and is used to execute commands on the tables on the
MySQL database. As a safeguard, we have implemented authorization using Laravel
Passports, which requires the request to include a Authorization header with a
\textc{bearer} token.
We have chosen this approach, as we want to ensure that only authorized sources are
able to edit the stored data. The implementation of the database API is
described in \autoref{DatabaseAPI}.

\subsection{Queue Server and API}
The queue server is used to handle and schedule requests from all the users
using the web application. In order to handle these requests we have developed
an API using C\# which is used as the server entry point. As this API is used to
start tasks unconditionally, it requires a safeguard in the form of an
authorization system, as hostile users would otherwise be able to overload our
system with fake requests. While we deem this to be necessary, the
authorization system is not yet implemented, as is discussed in
\autoref{disc:auth}. The implementation of the queue server and its API is
further described in \autoref{queueAPI}.

\subsection{Worker}
The core functionality of the system is to determine users political filter
bubble. This functionality is contained in the Worker. Whenever the queue server
receives a request to classify a user, it calls the methods contained in the
worker. This is further described in \autoref{workerLabel}.

\subsection{Multithreading}\label{subs:multithread}
In order to optimize the system performance, we have chosen to use multiple
threads for actions which can easily be split into parts. These actions are the
retrieval of tweets, and the following classification of tweets. For tweet
retrieval we make use of 3 threads, where each thread is working on retrieving
the tweets of a single user. As such, we can process 3 users concurrently. Based
on our general testing, this was chosen to be the optimal amount, as Twitter
occasionally terminated our requests if we had too many running concurrently.\\
For tweet classification, we make use of 5 threads, working together to analyze
the tweets of a single person at a time. This means that a single persons tweets
are split into 5 parts, analyzed, and the results are then combined into a
single classification. Splitting the classification into 5 threads have greatly
improved performance, which is documented in \autoref{test:multithread}.

\subsection{Singleton Class Structure}
Many of the classes in the developed system are defined as singletons, which
means that only a single instance is ever created. We have chosen this approach,
as it offers slight improvements over static classes, as we ensure that classes
are only stored on the stack if they are ever used. A potential problem with
this approach is that we use a multithreaded method for analyzing tweets, which
causes problems with accidentally trying to create multiple instances of the
classes. This however has been solved by using double checked locking to ensure
that there does only exists one instance of a singleton.

\subsection{Web Communication}
When retrieving data from the Twitter API, we have chosen to make use of
\textc{HttpWebRequet} instead of \textc{WebClient} as it allows us to have
more control over the requests. As an example the \textc{HttpWebRequest} have a
\textc{Timeout} property which we can modify to make the request able to wait
more before failing the request. This would otherwise only be possible if we
extended \textc{WebClient} and made our own webclient class, but we have
decided that this would be unnecessary, as it would imply extending a class only to
change a single property.

\subsection{Classification Models}
In order to determine a Twitter user's political leaning, we have developed two
different models, which are explained in \autoref{cha:classification}. The first
model uses a Bag-of-Words approach where a text is analyzed for
emotional, political, and news-related keywords. This approach is based partly
on the methodology described by \citep{sarlan2014twitter}.\\
The second approach uses a Naive Bayesian Network to determine a user's
political affiliation based on a set of training data built from the Twitter
data from American politicians.

















