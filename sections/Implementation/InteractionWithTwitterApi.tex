\chapter{Twitter API Interaction}\label{cha:twitterAPI}
Following the decision to use Twitter as the source for data in
\autoref{sec:social-media-conclusion}, this chapter will be used to document how
we interact with the Twitter API, and how we handle the authorisation required
to access their data. When accessing data through the Twitter API, each
requester has a limited amount of request they can make within a 15 minute time
span \citep{twitterRateLimit}. As an example, retrieving batches of tweets is
limited to 900 requests if made on behalf of a user, and 1500 requests if made
on behalf of an application \citep{twitterTimelineRateLimit}. This limit on
requests makes it impossible to upscale the system to service multiple users at
a time. As such, we have chosen that instead of making requests on behalf of our
application, we instead ask the user to authenticate their Twitter account with
our system, such that we can make requests on bahalf of their user instead.
However, Twitter enforces a different set of authentication requirements when
making requests from a users instead of an application \citep{TwitterAPIAuth}.
As such, this chapter will be used to describe how we make requests on behalf of
the user. 

\section{OAuth}
Whenever a user wants to request data through the Twitter API, Twitter requires
that request to conform with the OAuth 1.0 authorisation protocol
\citep{OAuth1}. This protocol requires the request to contain information about
the following\citep{TwitterAPIAuth}:

\begin{enumerate}
 	\item Which application is making the request
	\item Which user the request is posting on behalf of
	\item Whether the user has granted the application authorization to post on the
userâ€™s behalf 
	\item Whether the request has been tampered by a third party while in transit
\end{enumerate}

In order for a request to contain this information, we must create a Request
Header, which consists of a number of encrypted/unencrypted key-value pairs. 

\section{Request header}
As stated, for an \ac{HTTP} request to be valid in the Twitter API, it has to
contain seven key/pair values in the header \citep{TwitterAPIAuth}:

\begin{itemize}
  \item oauth\_consumer\_key
  \item oauth\_nonce
  \item oauth\_signature
  \item oauth\_signature\_method
  \item oauth\_timestamp
  \item oauth\_token
  \item oauth\_version
\end{itemize}

The values and how to get them is described in the following subsections:

\subsection*{Consumer key}
The consumer key is a unique token that identifies who makes the request.
This key is bound to the specific application, as such we can manually retrieve
it from the twitter website www.apps.twitter.com.

\subsection*{Nonce}
The nonce is a unique token generated for each request. This way, it can be
determined if a request has been submitted multiple times. As there is no
mandatory approach to generating this request, we have chosen to base it on a
combination of the request type (POST/GET), a requester's name, and a timestamp.

\subsection*{Signature}
The signature is used by Twitter to assure that the request has not been
modified after being sent. It works by encoding all information from the initial
request into a signature, and if this signature is not representative of the
request Twitter receives, it is considered as invalid \citep[sec
3.4]{OAuth1}. \\
In practice we do the following \citep{TwitterAPISignature}. We start by using
percent-encoding to encode: all the parameters, the request type, and the
key-value pairs. Then we concatenate all the encoded strings. \\
Following this, we concatenate two additional values which identify the
requesting user and the application, namely the \textc{OAuth token secret} and
the \textc{Consumer secret}. Here the Token Secret is unique to the user, and is
given to us by Twitter when the user authenticates with our application. The
Consumer Secret is a unique identifier for our application.\\
These two values are then percent-encoded, concatenated, and used as a key for a
HMAC-SHA1 encoding of the base string \citep{TwitterHMACSHA}. The output from
this encoding is now our signature.
 
\subsection*{Signature method}
The signature method for Twitter is always HMAC-SHA1, any request without this
signature method is invalid. HMAC-SHA1 means that the cryptography hash function
used is \ac{SHA-1} \citep{TwitterHMACSHA}.

\subsection*{Timestamp}
The timestamp is a string created together with the request. The string is the
number of seconds since the Unix epoch, which is 1/1/1970. It is used to
determine when the request was made. If a request is marked as created before
the Unix epoch, it is invalid.

\subsection*{Authorization token}
The token is used to identify the user who is making the request; each user has
a unique token kept secret. This token can be received by submitting a users
login details with Twitter. As such, a user must be authorised before making
requests. In combination with the token, a user also has a Token Secret. This
secret is used when creating the signature.

% that the application is allowed to
% interact with the user's account. It is generated by Twitter by going to
% apps.twitter.com and clicking on the application 
% \fix{}{maybe go in-depth on how this is done}

\subsection*{Version}
The version always has to be 1.0 for the API to accept the request; this is
because the Twitter \ac{API} only uses OAuth 1.0, as opposed to OAuth 2.0.

\section{Creating the string}
When all the necessary tokens have been generated, the authorization header
string itself can be created \citep{TwitterAPIAuth}. The finished header looks like this, where
\ldots\_val gets replaced with the corresponding token:\nl

OAuth oauth\_consumer\_key="oauth\_consumer\_key\_val",\\
oauth\_nonce="oauth\_nonce\_val", \\
oauth\_signature="oauth\_signature\_val", \\
oauth\_signature\_method="HMAC-SHA1", \\
oauth\_timestamp="oauth\_timestamp\_val", \\
oauth\_token="oauth\_token\_val", \\
oauth\_version="1.0" \\

This authorization header must then be supplied in the request to the Twitter
API whenever we make a request on behalf of the user.
