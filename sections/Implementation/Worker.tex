\chapter{Worker}\label{workerLabel}
The worker is the part of the system which collects the tweets and analyzes
them. Each task in the queue corresponds to a worker. 

\section{Implementation}
The worker first retrieves the user which the screen name corresponds to. Then
it retrieves the list of tweets by the user. The next step for the
worker is to retrieve the list of users that the user is following, retrieve
their tweets and analyse the tweets. The retrievement of tweets and the
analysis are done in parallel by splitting them into tasks.

\subsection{Tweet retriever} \label{sub:tweetretriever}
There are two versions of the whole tweet retrievement process. The first
version is a legacy version that retrieves tweets and saves them in files
locally to be analyzed at a later point. The new implementation retrieves and
analyzes each twitter account on their own thread to save time. The code from
back when the legacy version was written, is moved to the helper function
\textc{GetTweetsFromUser}, which both the versions wraps around. To make this
work, the helper function, among others, receives the \textc{retrieveMethod} as
a parameter. Since this parameter is of the type \textc{Func<List<Tweet>>}, the
helper function can take any function as parameter as long as it returns a list
of tweets.
This can be seen on the three methods in the three code examples
\autoref{legacyUserTweet}, \autoref{NewUserTweet} and
\autoref{UserTweetHelper} where the calls on \textbf{line 3} in the two
wrapper methods give the last parameter as a lambda expression / anonymous
function, which takes no input as seen by \textc{() =>}.\\

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Legacy method call , label = legacyUserTweet ] 
public List<Tweet> GetTweetsFromUser(User user, AuthObj auth)
{	
    return GetTweetsFromUserHelper(user, auth, (() => TweetThreadMethod(user, auth)));
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Current method call to speed up execution , label =
NewUserTweet ] 
public void GetTweetsFromUserAndAnalyse(User user, AuthObj auth, Func<User, bool> get, Func<List<Tweet>, AnalysisResultObj> classifyMethod, Func<AnalysisResultObj, User, bool> post)
{
    GetTweetsFromUserHelper(user, auth, (() => TweetThreadMethod(user, auth, get, classifyMethod, post)));
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = The GetTweetsFromUserHelper, label =
UserTweetHelper]
private List<Tweet> GetTweetsFromUserHelper(User user, AuthObj auth, Func<List<Tweet>> retrieveMethod)
{
    List<Tweet> tweetList = new List<Tweet>();
    Task<List<Tweet>> task = new Task<List<Tweet>>(() => retrieveMethod());
    task.Start();
    task.Wait();
    tweetList.AddRange(task.Result);

    return tweetList;
}
\end{lstlisting}
\end{minipage}

The helper was made to reuse code, because the only change would be the function to be
called in the task on \textbf{line 3}.\\

\subsection{Splitting up in tasks}

To speed up the retrievement of tweets, it is split up in tasks that are run in
parallel. It is split such that each user, the user is following, corresponds
to a task. This way, the tasks are somewhat equally split. 
When the worker analyzes the tweets, be it while retrieving or from a file, it
also needs to split the list of tweets into tasks, such that it is possible to work on a smaller subset of the
problem. Here, the splitting is done such that each task gets an equal amount of
tweets.

The main difference between how the task splits are done in the retrievement
part and the analysis part is that in the retrievement part, a predefined number
of tasks can run at the same time, even though the total number of tasks may be
higher, whereas the analysis part always has all its predefined number of tasks
running at the same time. The predefined number of the latter may be 1 higher if
it can not split the tasks equally. In this case, the excess tasks are
put in their own small task. 

\subsection{Retrieve method}
As mentioned in \autoref{sub:tweetretriever}, the \textc{retrieveMethod}
parameter can be replaced with any function that returns a list of tweets. Both
versions send the function \textc{TweetThreadMethod}, shown on
\autoref{tweetthreadmethod}. \\

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = The TweetThreadMethod function, label =
tweetthreadmethod]
private List<Tweet> TweetThreadMethod(User user, AuthObj auth, Func<User, bool> checkDB = null, Func<List<Tweet>, AnalysisResultObj> classifyMethod = null, Func<AnalysisResultObj, User, bool> postToDB = null)
{
    bool alreadyExist = false;
    AnalysisResultObj tempResult = new AnalysisResultObj();
    List<Tweet> temp = new List<Tweet>();
    if (checkDB != null)
    {
        alreadyExist = checkDB(user); //Uses the supplied method to find out if the result already exist on the database
        if (alreadyExist)
        {
            Log.Debug(String.Format("{0,-30} {1,-20} {2,-11}", user.Name, user.Id, "Already exist in db"));
        }
    }

    if (!alreadyExist)
    {
        temp = RetrieveTweets(user, auth);
        if (user.IsProtected)
        {
            Log.Debug(String.Format("{0,-30} {1,-20} {2,-11}", user.Name, user.Id, "Protected"));
        }
        else
        {
            Log.Debug(String.Format("{0,-30} {1,-20} {2,-11}", user.Name, user.Id, temp.Count));
        }

        if (classifyMethod != null && postToDB != null)
        {
            tempResult = classifyMethod(temp); //Use the supplied method to classify the list of tweets
            postToDB(tempResult, user); //Use the supplied method to post the result to the database
            temp = new List<Tweet>();
        }
    }

    return temp;
}
\end{lstlisting}
\end{minipage}
The difference is that this function has a bunch of optional parameters. The legacy version only parses
a user and an authorization object, while the new version also parses the
function \textc{checkDB}, an analysis result object and the function
\textc{postToDB}. checkDB is used to check if the user is already in the
database. If it is, it skips the tweet retrievement and analysis of the
particular user. If it is not, it retrieves the tweets and analyzes them if it
is the new version.
\fix{}{Needs more maybe.}
