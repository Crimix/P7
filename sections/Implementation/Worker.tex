\chapter{Worker}\label{workerLabel}
The worker is the part of the system which collects the tweets and analyzes
them. Each task in the queue corresponds to a worker. 

\section{Implementation}
The worker first retrieves the user which the screen name corresponds to. Then,
it retrieves the list of tweets by the user. The next step for the
worker is to retrieve the list of users that the user is following, retrieve
their tweets and analyse the tweets. The retrievement of tweets and the
analysis are done in parallel by splitting them into tasks. To retrieve and
analyze tweets, it uses the functions \textc{GetTweetsFromUserAndAnalyse} and
\textc{GetTweetsFromFriendsAndAnalyse} to receive and analyse tweets from the
user and the users it follows respectively. These functions are found in the
class called \textc{TweetRetriever}.

\subsection{Tweet retriever} \label{sub:tweetretriever}
There are two versions of the whole tweet retrievement process. The first
version is a legacy version that retrieves tweets and returns them as one list
such that they can be saved in files locally or to be analyzed at a later
point.
The new implementation retrieves and analyzes each Twitter account on their own
thread to save time. The code from back when the legacy version was written, is moved to the helper function
\textc{GetTweetsFromUserHelper}, which both the versions wraps around. To make
this work, the helper function, among others, receives the \textc{retrieveMethod} as
a parameter. Since this parameter is of the type \textc{Func<List<Tweet>>}, the
helper function can take any function as parameter as long as it returns a list
of tweets.
This can be seen on the three methods in the three code examples
\autoref{legacyUserTweet}, \autoref{NewUserTweet} and
\autoref{UserTweetHelper} where the calls on \textbf{line 3} in the two
wrapper methods give the last parameter as a lambda expression / anonymous
function, which takes no input as seen by \textc{() =>}.\\

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Legacy method call , label = legacyUserTweet ] 
public List<Tweet> GetTweetsFromUser(User user, AuthObj auth)
{	
    return GetTweetsFromUserHelper(user, auth, (() => TweetThreadMethod(user, auth)));
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Current method call to speed up execution , label =
NewUserTweet ] 
public void GetTweetsFromUserAndAnalyse(User user, AuthObj auth, Func<User, bool> get, Func<List<Tweet>, AnalysisResultObj> classifyMethod, Func<AnalysisResultObj, User, bool> post)
{
    GetTweetsFromUserHelper(user, auth, (() => TweetThreadMethod(user, auth, get, classifyMethod, post)));
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = The GetTweetsFromUserHelper, label =
UserTweetHelper]
private List<Tweet> GetTweetsFromUserHelper(User user, AuthObj auth, Func<List<Tweet>> retrieveMethod)
{
    List<Tweet> tweetList = new List<Tweet>();
    Task<List<Tweet>> task = new Task<List<Tweet>>(() => retrieveMethod());
    task.Start();
    task.Wait();
    tweetList.AddRange(task.Result);

    return tweetList;
}
\end{lstlisting}
\end{minipage}

The helper was made to reuse code, because the only change would be the function to be
called in the task on \textbf{line 4}.\\

\subsubsection{Retrieve method}
As mentioned in \autoref{sub:tweetretriever}, the \textc{retrieveMethod}
parameter can be replaced with any function that returns a list of tweets. Both
versions send the function \textc{TweetThreadMethod}, shown on
\autoref{tweetthreadmethod}. \\

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = The TweetThreadMethod function, label =
tweetthreadmethod]
private List<Tweet> TweetThreadMethod(User user, AuthObj auth, Func<User, bool> checkDB = null, Func<List<Tweet>, AnalysisResultObj> classifyMethod = null, Func<AnalysisResultObj, User, bool> postToDB = null)
{
    bool alreadyExist = false;
    AnalysisResultObj tempResult = new AnalysisResultObj();
    List<Tweet> temp = new List<Tweet>();
    if (checkDB != null)
    {
        alreadyExist = checkDB(user);
		...
    }

    if (!alreadyExist)
    {
        temp = RetrieveTweets(user, auth);
		...	
        if (classifyMethod != null && postToDB != null)
        {
            tempResult = classifyMethod(temp); 
            postToDB(tempResult, user); 
            temp = new List<Tweet>();
        }
    }

    return temp;
}
\end{lstlisting}
\end{minipage}
The difference is that this function has a bunch of optional parameters. The legacy version only parses
a user and an authorization object, while the new version also parses the
functions \textc{checkDB}, \textc{classifyMethod} and \textc{postToDB}.
\textc{checkDB} is used to check if the user is already in the database. If it
is, it skips the tweet retrievement and analysis of the particular user. If it is not, it retrieves the tweets and analyzes them if it
is the new version.\\

\subsection{Anonymous functions}
The three anonymous functions mentioned in \autoref{sub:tweetretriever} -
\textc{checkDB}, \textc{classifyMethod} and \textc{postToDB} are defined in the
worker class under the names of \textc{CheckOfResultExistOnDB},
\textc{ClassifyTweet} and \textc{PostResultToDB} respectively, where there are two versions of \textc{CheckOfResultExistOnDB} and
\textc{PostResultToDB}, the only aspect which is different is that the two other versions, links the user being analyses to the overall user. These are defined
in \textc{Worker} rather than \textc{TweetRetriever} because they are different
for each worker, because of the \textc{userRecordId} which is different for each request, such a thing
cannot be defined in the singleton class without the need to pass the id to each method.
This way it is still the workers methods that are used in a context where they have access to what is defined in the worker.

\subsection{Splitting up in tasks}
To speed up the retrievement of tweets, the retrievement is split up in tasks
that are run in parallel. It is split such that each user, the user is following, corresponds
to a task. This way, the tasks are somewhat equally split. 
When the worker analyzes the tweets, be it while retrieving, from a file or
just a list of tweets, it also needs to split the list of tweets into tasks,
such that it is possible to work on a smaller subset of the problem. Here, the splitting is done such that each task gets an equal amount of
tweets.

The main difference between how the task splits are done in the retrievement
part and the analysis part is that in the retrievement part, a predefined number
of tasks can run at the same time, even though the total number of tasks may be
higher, whereas the analysis part always has all its predefined number of tasks
running at the same time. The predefined number of the latter may be 1 higher if
it can not split the tasks equally. In this case, the excess tasks are
put in their own small task. 

\fix{}{Needs more maybe.}
