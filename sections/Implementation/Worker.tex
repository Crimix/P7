\chapter{Worker}\label{workerLabel}
The worker is the part of the system which collects the tweets and analyzes
them. Each task in the queue corresponds to a worker. 

\section{Implementation}
The worker first retrieves the user which the screen name corresponds to. Then
it retrieves the list of tweets by the user. The next step for the
worker is to retrieve the list of users that the user is following, retrieve
their tweets and analyse the tweets. The retrievement of tweets and the
analysis are done in parallel by splitting them into tasks.

\subsection{Tweet retriever}
There are two versions of the whole tweet retrievement process. The first
version is a legacy version that retrieves tweets and returns them as one list
such that they can be saved in files locally or to be analyzed at a later
point.
The new implementation retrieves and analyzes each Twitter account on their own
thread to save time. The code from back when the legacy version was written, is moved to the helper function
\textc{GetTweetsFromUserHelper}, which both the versions wraps around. To make
this work, the helper function, among others, receives the \textc{retrieveMethod} as
a parameter. Since this parameter is of the type \textc{Func<List<Tweet>>}, the
helper function can take any function as parameter as long as it returns a list
of tweets.
This can be seen on the three methods in the three code examples
\autoref{legacyUserTweet}, \autoref{NewUserTweet} and
\autoref{UserTweetHelper} where the calls on \textbf{line 3} in the two
wrapper methods give the last parameter as a lambda expression / anonymous
function, which takes no input as seen by \textc{() =>}.\\

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Legacy method call , label = legacyUserTweet ] 
public List<Tweet> GetTweetsFromUser(User user, AuthObj auth)
{	
    return GetTweetsFromUserHelper(user, auth, (() => TweetThreadMethod(user, auth)));
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Current method call to speed up execution , label =
NewUserTweet ] 
public void GetTweetsFromUserAndAnalyse(User user, AuthObj auth, Func<User, bool> get, Func<List<Tweet>, AnalysisResultObj> classifyMethod, Func<AnalysisResultObj, User, bool> post)
{
    GetTweetsFromUserHelper(user, auth, (() => TweetThreadMethod(user, auth, get, classifyMethod, post)));
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = The GetTweetsFromUserHelper, label =
UserTweetHelper]
private List<Tweet> GetTweetsFromUserHelper(User user, AuthObj auth, Func<List<Tweet>> retrieveMethod)
{
    List<Tweet> tweetList = new List<Tweet>();
    Task<List<Tweet>> task = new Task<List<Tweet>>(() => retrieveMethod());
    task.Start();
    task.Wait();
    tweetList.AddRange(task.Result);

    return tweetList;
}
\end{lstlisting}
\end{minipage}

The helper was made to reuse code, because the only change would be the function to be
called in the task on \textbf{line 4}.\\

\subsection{Splitting up in tasks}
To speed up the retrievement of tweets, the retrievement is split up in tasks
that are run in parallel. It is split such that each user, the user is following, corresponds
to a task. This way, the tasks are somewhat equally split. 
When the worker analyzes the tweets, be it while retrieving, from a file or
just a list of tweets, it also needs to split the list of tweets into tasks,
such that it is possible to work on a smaller subset of the problem. Here, the splitting is done such that each task gets an equal amount of
tweets.

The main difference between how the task splits are done in the retrievement
part and the analysis part is that in the retrievement part, a predefined number
of tasks can run at the same time, even though the total number of tasks may be
higher, whereas the analysis part always has all its predefined number of tasks
running at the same time. The predefined number of the latter may be 1 higher if
it can not split the tasks equally. In this case, the excess tasks are
put in their own small task. 

\subsection(Anonymous functions)

\fix{}{Needs more maybe.}
